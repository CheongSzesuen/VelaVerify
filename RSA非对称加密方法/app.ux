<!-- app.ux -->
<script>

  import interconnect from "@system.interconnect"
  import { showToast } from "@system.prompt" // 如果需要在全局处理中显示提示

  // 初始化 interconnect 实例
  const connect = interconnect.instance()

  export default {
    // 将 connect 实例暴露给全局，供页面访问
    connectInstance: connect,

    // 可以在这里定义一些全局的连接状态管理逻辑（可选）
    // 例如，维护一个全局的连接状态变量，供多个页面共享
    // globalConnectionStatus: "未初始化",

    // 应用启动时执行一次的初始化逻辑
    onCreate() {
      console.log("App created, initializing interconnect...");

      // 设置全局的消息接收回调
      // 注意：这里的 this 指向 $app 对象
      connect.onmessage = (data) => {
        console.log("Global onmessage received:", data);
        // 可以在这里做一些全局处理，比如更新全局状态、发送事件等
        // 但具体页面逻辑最好还是在页面内处理
        // 例如，可以广播一个事件通知所有页面
        // this.$broadcast('interconnectMessage', data);

        // 或者，如果只有一个页面关心，可以直接调用页面方法（但这耦合度高）
        // if (this.currentPage && typeof this.currentPage.handleInterconnectMessage === 'function') {
        //   this.currentPage.handleInterconnectMessage(data);
        // }

        // 示例：全局显示提示
        // showToast({ message: "App: 接收到新数据", duration: 500 })
      };

      // 设置全局的连接打开回调
      connect.onopen = (data) => {
        console.log("Global onopen:", data);
        // this.globalConnectionStatus = "已连接";
        // this.$broadcast('interconnectOpen', data);
        showToast({ message: "App: 连接已建立", duration: 500 });
      };

      // 设置全局的错误处理
      connect.onerror = (error) => {
        console.error("Global onerror:", error);
        // this.globalConnectionStatus = "连接错误";
        // this.$broadcast('interconnectError', error);
        showToast({ message: "App: 连接出错", duration: 500 });
      };

      // 设置全局的连接关闭处理
      connect.onclose = () => {
        console.log("Global onclose");
        // this.globalConnectionStatus = "已断开";
        // this.$broadcast('interconnectClose');
        showToast({ message: "App: 连接已断开", duration: 500 });

        // 尝试重新连接 (注意：在全局处理重连需谨慎，确保不会与页面逻辑冲突)
        // setTimeout(() => {
        //   console.log("Attempting to reconnect...");
        //   connect.open();
        // }, 5000);
      };

      // 注意：通常不在 onCreate 里立即调用 connect.open()
      // 因为此时可能还没有页面准备好处理连接状态。
      // 更常见的做法是在需要连接的页面的 onShow 中调用 connect.open()
      // 或者由一个专门的启动逻辑页面来处理。
    }

    // 可以在 onDestroy 中做一些清理工作（如果需要）
    // onDestroy() {
    //   console.log("App destroyed, cleaning up...");
    //   // 注意：通常不在此处调用 connect.close()，
    //   // 因为应用退出时连接通常会自动关闭。
    //   // 如果需要手动关闭，确保逻辑正确。
    // }
  }
</script>